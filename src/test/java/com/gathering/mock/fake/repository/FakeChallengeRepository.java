package com.gathering.mock.fake.repository;

import com.gathering.challenge.model.domain.ChallengeDomain;
import com.gathering.challenge.model.entity.Challenge;
import com.gathering.challenge.repository.ChallengeRepository;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicLong;

public class FakeChallengeRepository implements ChallengeRepository {

    private final AtomicLong autoGeneratedId = new AtomicLong(0);
    private List<ChallengeDomain> data = new ArrayList<>();

    @Override
    public ChallengeDomain save(ChallengeDomain challenge) {
        if(Objects.isNull(challenge.getId())) {
            final ChallengeDomain createChallenge = ChallengeDomain.builder()
                    .id(autoGeneratedId.incrementAndGet())
                    .challengeUsers(new ArrayList<>())
                    .challengeStatus(challenge.getChallengeStatus())
                    .completeRate(challenge.getCompleteRate())
                    .startDate(challenge.getStartDate())
                    .endDate(challenge.getEndDate())
                    .readingTimeGoal(challenge.getReadingTimeGoal())
                    .build();
            data.add(createChallenge);
            return createChallenge;
        } else {
            data.removeIf(item -> Objects.equals(item.getId(), challenge.getId()));
            data.add(challenge);
            return challenge;
        }
    }

    @Override
    public ChallengeDomain getByIdWithChallengeUsers(Long challengeId) {
        return data.stream().filter(item -> item.getId() == challengeId).findFirst().get();
    }

    @Override
    public Challenge findById(Long challengeId) {
        return null;
    }

    @Override
    public List<Challenge> getByIdsIn(List<Long> challengeIds) {
        return null;
    }
}
