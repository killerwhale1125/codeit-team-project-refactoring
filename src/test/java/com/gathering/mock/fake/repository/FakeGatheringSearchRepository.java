package com.gathering.mock.fake.repository;

import com.gathering.common.base.exception.BaseException;
import com.gathering.common.base.response.BaseResponseStatus;
import com.gathering.gathering.domain.GatheringDomain;
import com.gathering.gathering.domain.GatheringSearch;
import com.gathering.gathering.domain.GatheringSortType;
import com.gathering.gathering.domain.GatheringStatus;
import com.gathering.gathering.service.dto.GatheringPageResponse;
import com.gathering.gathering.service.dto.GatheringSliceResponse;
import com.gathering.gathering.service.port.GatheringSearchRepository;
import com.gathering.gathering_user.domain.GatheringUserStatus;

import java.time.LocalDate;
import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;

public class FakeGatheringSearchRepository implements GatheringSearchRepository {

    private final AtomicLong autoGeneratedId = new AtomicLong(0);
    private List<GatheringDomain> data = new ArrayList<>();

    @Override
    public GatheringSliceResponse findGatherings(GatheringSearch gatheringSearch, int page, int size) {
        List<GatheringDomain> filteredList = data.stream()
                .filter(gathering -> gatheringSearch.getBookTitle() == null || gathering.getBook().getTitle().equals(gatheringSearch.getBookTitle()))
                .filter(gathering -> gatheringSearch.getStartDate() == null || gathering.getStartDate().isAfter(gatheringSearch.getStartDate()))
                .filter(gathering -> gatheringSearch.getEndDate() == null || gathering.getEndDate().isBefore(gatheringSearch.getEndDate()))
                .filter(gathering -> gatheringSearch.getReadingTimeGoals() == null || gatheringSearch.getReadingTimeGoals().contains(gathering.getChallenge().getReadingTimeGoal()))
                .filter(gathering -> gatheringSearch.getGatheringStatus() == null || gathering.getGatheringStatus().equals(gatheringSearch.getGatheringStatus()))
                .sorted(applySorting(gatheringSearch.getGatheringSortType()))
                .collect(Collectors.toList());

        int start = page * size;
        int end = Math.min((start + size), filteredList.size());

        List<GatheringDomain> pageContent = (start < end) ? filteredList.subList(start, end) : Collections.emptyList();
        boolean hasNext = end < filteredList.size();

        return GatheringSliceResponse.builder()
                .gatherings(pageContent)
                .hasNext(hasNext)
                .build();
    }

    private Comparator<GatheringDomain> applySorting(GatheringSortType gatheringSortType) {
        Comparator<GatheringDomain> comparator = (g1, g2) -> 0; // 기본은 비교 없음

        switch (gatheringSortType) {
            case DEADLINE_ASC:
                comparator = Comparator.comparing(GatheringDomain::getEndDate);
                break;
            case PARTICIPANTS_DESC:
                comparator = Comparator.comparing(GatheringDomain::getCurrentCapacity).reversed();
                break;
            case VIEWS_DESC:
                comparator = Comparator.comparing(GatheringDomain::getViewCount).reversed();
                break;
            case NEWEST_FIRST:
                comparator = Comparator.comparing(GatheringDomain::getStartDate).reversed();
                break;
        }

        return comparator;
    }

    @Override
    public GatheringPageResponse findGatheringsForUserByUsername(String username, int page, int size, GatheringStatus gatheringStatus, GatheringUserStatus gatheringUserStatus) {
        List<GatheringDomain> filteredList = data.stream()
                .filter(gathering -> gathering.getGatheringUsers().stream()
                        .anyMatch(gatheringUser -> gatheringUser.getUser().getUserName().equals(username)
                                && gatheringUser.getGatheringUserStatus().equals(gatheringUserStatus)))
                .filter(gathering -> gathering.getGatheringStatus().equals(gatheringStatus))
                .collect(Collectors.toList());

        int start = page * size;
        int end = Math.min((start + size), filteredList.size());

        List<GatheringDomain> gatherings = (start < end) ? filteredList.subList(start, end) : Collections.emptyList();
        long totalCount = filteredList.size();

        return GatheringPageResponse.builder()
                .gatherings(gatherings)
                .totalCount(totalCount)
                .build();
    }

    @Override
    public GatheringPageResponse findMyCreated(String username, int page, int size) {
        List<GatheringDomain> filteredList = data.stream()
                .filter(item -> Objects.equals(item.getOwner(), username))
                .collect(Collectors.toList());

        int start = page * size;
        int end = Math.min((start + size), filteredList.size());
        List<GatheringDomain> gatherings = (start < end) ? filteredList.subList(start, end) : Collections.emptyList();
        long totalCount = filteredList.size();

        return GatheringPageResponse.builder()
                .gatherings(gatherings)
                .totalCount(totalCount)
                .build();
    }

    @Override
    public GatheringPageResponse findMyWishes(Set<Long> wishGatheringIds, int page, int size) {
        return null;
    }

    @Override
    public GatheringSliceResponse findJoinableGatherings(GatheringSearch gatheringSearch, int page, int size) {
        return null;
    }

    @Override
    public GatheringDomain getByIdWithChallengeAndBook(Long gatheringId) {
        return data.stream().filter(item -> Objects.equals(item.getId(), gatheringId))
                .findFirst()
                .orElseThrow(() -> new BaseException(BaseResponseStatus.NON_EXISTED_GATHERING));
    }

    @Override
    public GatheringPageResponse findGatheringsBySearchWordAndTypeTitle(String searchWord, int page, int size) {
        return null;
    }

    @Override
    public GatheringPageResponse findGatheringsBySearchWordAndTypeContent(String searchWord, int page, int size) {
        return null;
    }

    @Override
    public GatheringPageResponse findGatheringsBySearchWordAndTypeBookName(String searchWord, int page, int size) {
        return null;
    }

    @Override
    public List<Long> findCompletedGatheringBookIdsByUserId(Long id) {
        return null;
    }


    public GatheringDomain save(GatheringDomain gathering) {
        if(Objects.isNull(gathering.getId())) {
            GatheringDomain createGathering = GatheringDomain.builder()
                    .id(autoGeneratedId.incrementAndGet())
                    .name(gathering.getName())
                    .content(gathering.getContent())
                    .startDate(gathering.getStartDate())
                    .endDate(gathering.getEndDate())
                    .minCapacity(gathering.getMinCapacity())
                    .maxCapacity(gathering.getMaxCapacity())
                    .currentCapacity(gathering.getCurrentCapacity())
                    .owner(gathering.getOwner())
                    .viewCount(gathering.getViewCount())
                    .gatheringStatus(gathering.getGatheringStatus())
                    .gatheringWeek(gathering.getGatheringWeek())
                    .book(gathering.getBook())
                    .challenge(gathering.getChallenge())
                    .image(gathering.getImage())
                    .gatheringUsers(new ArrayList<>())
                    .build();
            data.add(createGathering);
            return createGathering;
        } else {
            data.removeIf(item -> Objects.equals(item.getId(), gathering.getId()));
            data.add(gathering);
            return gathering;
        }
    }

    private boolean matchesCriteria(GatheringDomain gathering, GatheringSearch gatheringSearch) {
        boolean matches = true;

        if (gatheringSearch.getBookTitle() != null) {
            matches &= gathering.getBook().getTitle().equals(gatheringSearch.getBookTitle());
        }
        if (gatheringSearch.getStartDate() != null) {
            matches &= gathering.getStartDate().equals(gatheringSearch.getStartDate());
        }

        if (gatheringSearch.getReadingTimeGoals() != null) {
            matches &= gathering.getChallenge().getReadingTimeGoal().equals(gatheringSearch.getReadingTimeGoals());
        }

        if (gatheringSearch.getGatheringStatus() != null) {
            matches &= gathering.getGatheringStatus().equals(gatheringSearch.getGatheringStatus());
        }
        if (gatheringSearch.getToday() != null && gatheringSearch.getToday()) {
            matches &= gathering.getStartDate() == LocalDate.now();
        }

        return matches;
    }
}
